# API Standards

This document is an internal resource that is visible to our customers and anyone else that's interested in our API standards. It is here to enable discussion, agreement and alignment on API standards. It will help us build consistent APIs resulting in a fantastic API experience for those building and consuming our APIs.

## Contents

- [OpenAPI](#openapi)
- [API Style](#api-style)
- [Authentication](#authentication)
- [API Versioning](#api-versioning)
- [URL Structure](#url-structure)
- [HTTP Verbs](#http-verbs)
- [HTTP Status Codes](#http-status-codes)
- [Resource Names](#resource-names)
- [Resource Payload Structure](#resource-payload-structure)
- [Parameters and Properties](#parameters-and-properties)
- [Querying to Search or Filter](#querying-to-search-or-filter)
- [Pagination](#pagination)
- [Errors](#errors)
- [Rate Limits](#rate-limits)
- [Acknowledgements & References](#acknowledgements-references)
- [TODO](#todo)


## OpenAPI

APIs are documented using OpenAPI v3. [See Open API versions](https://github.com/OAI/OpenAPI-Specification/tree/master/versions) because it's the most widely understood and adoped API specification standard.

## API Style

Our APIs are [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) opposed to RPC or a Query Language such as GraphQL because it is the most widely adopted and understood approach to building APIs.

## Authentication

### API Requests

API requests to product resources should be authenticated using an [OAuth2 Access Token](https://tools.ietf.org/html/rfc6749#section-1.4). The access token should be within the `Authorization` HTTP header.

Example:

```
GET /resource
Host​: api.example.com

Authorization: Bearer {access_token}
```

API requests to dedicated OAuth2 endpoints such as `/token` (used to create access tokens) and `/revoke` should authenticate requests using basic authentication. In the request the `Authentication` HTTP header value should be composed of `Basic` plus a Base64 value generated by concatenating a `client_id`, a colon (":") and a `client_secret`.

Example:

```
POST /token
Host​: api.example.com

Authorization: Basic {Base64(client_id + ":" + client_secret)}
```

### Webhooks & Callbacks

To be decided

## API Versioning

Versioning of APIs is within the URL because it's the mostly commonly used approach today and provides a clear visual representation of the version within documentation. The URL will contain only the MAJOR version (from MAJOR.MINOR.PATCH in [Semanitic Versioning](https://semver.org/)).

Note: Request and response API parameters may be added to a MAJOR version as these are not classed as breaking changes.

Examples

- `https://api.example.com/v1/users`
- `https://api.example.com/v1/projects`

Resources may existing for one version but not another. e.g.

- `https://api.example.com/v2/users` // 200
- `https://api.example.com/v2/projects` // 404

The full API version of `MAJOR.MINOR.PATCH` will be included in a `X-TRU-API-VERSION` HTTP response header.

Example:

```
GET /v1/projects/523 HTTP/1.1
Host: api.example.org
Accept: application/hal+json

HTTP/1.1 200 OK
Content-Type: application/hal+json
X-TRU-API-VERSION: 1.2.1

{
	"_links": {
		"self": { "href": "/projects/523" },
	},
	"project_id": 523
	"name": "A Project",
}
```

## URL Structure

The URL structure that our APIs follow is:

`https://{data_residency}.api.tru.id/{product_grouping}/{version}/{resource}`

The key pieces of information are outlined below along with where they are represented within an API request:

| Information				| Where in API request 	| Identifier						|
|---------------------------|-----------------------|-----------------------------------|
| Data Residency 			| URL subdomain 		| `{data_residency}` 				|
| Account ID 				| Request auth token	| N/A								|
| Project					| Request auth token	| N/A								|
| Product/logical Grouping	| Request path			| `{product_grouping}`				|
| Versioning				| Request path			| `{version}`						|
| Resource					| Request path			| `{resource}`						|
| Credentials/Auth Token	| Request Header		| `Authorization: Bearer {token}`	|

Examples:

- `https://eu.api.tru.id/phone_check/v1/checks`
- `https://us.api.tru.id/console/v1/projects`
- `https://eu.api.tru.id/console/v1/users`

## HTTP Verbs

Use HTTP methods appropriately for the operation you are performing. CRUD (Create, Read, Update, Delete) operations and the correct response for each are as follows:

- `GET` = read. Lists the resources in a collection or a single resource. Returns a 200 HTTP status code and the requested resource(s)
- `POST` = create. Creates a new resource in a collection. Returns a `201` HTTP status code if the new resource has been fully created. Returns a `202` status code and as much information as is currently available if the resource is being created asynchronously.
- `PUT` = replace. Replaces a a resource with the supplied representation. Returns a 200 HTTP status code and the updated resource.
- `PATCH` = update. Partially updates a resource with the supplied properties. Returns a 200 HTTP status code and the udpated resource.
- `DELETE` = delete. Removes a resource. Returns a 204 HTTP status code and no body.

Examples

- `GET /projects` - lists all the resources of the collection `projects`
- `GET /projects/{project_id}` - lists the details of the single project resource from the `projects` collection
- `POST /projects -d '{"name": "My first project"'` - create a new project
- `PUT /projects/{project_id} -d '{"name": "Only X"}'` - Replaces all the resource details. In this example the `name` is changed
- `PATCH /projects/{project_id} -d '{"name": "A more descriptive name"}'` - Update only the project name (TODO: update to JSON-PATCH)
- `DELETE /projects/{project_id}` - Remove the project identified by `{project_id}` from the collection

Within the OpenAPI specification and thus the rendered API References the operations must be ordered as follows:

• POST
• GET all
• GET by ID
• PUT
• PATCH
• DELETE

## HTTP Status Codes

### 200

The most commonly used HTTP status code in response to a successful API request. Exceptions are:

- [201](#anchor-201) for successful `POST` requests
- [202](#anchor-202) for successful `POST` requests where the resource hasn't been fully created
- [204](#anchor-202) for successful `DELETE` request

### 201

Indicates a resource has been created following a successful `POST` request.

### 202

Indicates a `POST` request has been accepted successfully but the underlying resources has not yet been fully created.

### 204

Indicates a successful `DELETE` request and the resource has been deleted.

### 400

Indicates a generic problem with the API request where there isn't a more suitable and specific error code available.

Example:

```
HTTP/1.1 400 Bad Request
Content-Type: application/problem+json
Retry-After: 3600

{
	"type": "https://example.com/docs/api-errors#bad-request",
	"title": "Bad Request",
	"detail": "The request failed due to: invalid parameters. See 'invalid_parameters' for more information.",
	"invalid_parameters": [
		{
			"name": "name",
			"reason": "exceeded the maximum string length of 256 characters",
			"api_reference_link": "https://example.com/docs/api_reference#projects-parameters-name"
		}
	],
	"instance": "https://example.com/console/http-logs/{log_id}"
}
```

### 401

The API request has failed to authenticate.

Example:

```
HTTP/1.1 401 Unauthorized
Content-Type: application/problem+json

{
	"type": "https://example.com/docs/api-errors#unauthorized",
	"title": "Unauthorized",
	"detail": "Authorization has been refused for the provided credentials.",
	"documentation_link": "https://example.com/docs/guides/authentication"
}
```

### 403

The request has successfully authenticated but the API will not authorize it because the credentials do not give sufficient permissions to access the resource.

There are very limited situations where 403 should be used because an API should not expose the existence of a resource to an unauthorized user. In most instances the API should return a [404](#anchor-404).

### 404

The resource could not be found, or the authenticating user does not have access to the resource.

Example:

```
HTTP/1.1 404 Not Found
Content-Type: application/problem+json

{
	"type": "https://example.com/docs/api-errors#not-found",
	"title": "Not Found",
	"detail": "The resource you are looking for was not found",
	"instance": "https://example.com/console/http-logs/{log_id}"
}
```

### 405

The request HTTP verb is not allowed on the resource.

Example:

```
HTTP/1.1 405 Method Not Allowed
Content-Type: application/problem+json

{
	"type": "https://example.com/docs/api-errors#method-not-allowed",
	"title": "Request Method Not Allowed",
	"detail": "Request method 'OPTIONS' not supported",
	"instance": "https://example.com/console/http-logs/{log_id}"
}
```

### 406

The `Accept` header is not supported as a response from the resource.

Example:

```
HTTP/1.1 406 Not Acceptable
Content-Type: application/problem+json

{
	"type": "https://example.com/docs/api-errors#not-acceptable",
	"title": "Request 'Accept' Header Not Supported",
	"detail": "Request 'Accept' header not supported. Must be one of the following: 'application/json', 'application/hal+json'",
	"instance": "https://example.com/console/http-logs/{log_id}",
	"api_reference_link": "https://example.com/docs/api_reference#project-accept"
}
```

### 409

The request could not be completed due to a conflict with the current state of the resource. Examples where this may be applicable:

- The resource has been created with a `202` response and an asynchronous process has not yet completed.
- A resource is being updated by another background task and updates are presently locked.

In both of these cases further modifications to the resource are not allowed until that process has completed.

Example:

```
HTTP/1.1 409 Conflict
Content-Type: application/problem+json

{
	"type": "https://example.com/docs/api-errors#conflict",
	"title": "Conflict: Resource Not Ready",
	"detail": "The resource cannot be updated until a background process has completed",
	"instance": "https://example.com/console/http-logs/{log_id}"
}
```

### 410

The requested resource is no longer available. This condition is expected to be considered permanent. Used when the URL is formatted correctly, but the resource is no long available e.g. if the resource has been deleted.

Example:

```
HTTP/1.1 410 Gone
Content-Type: application/problem+json

{
	"type": "https://example.com/docs/api-errors#gone",
	"title": "Conflict: Resource Not Ready",
	"detail": "The resource at this location no longer exists.",
	"instance": "https://example.com/console/http-logs/{log_id}"
}
```

### 415

The supplied request `Content-Type` cannot be handled by the resource.

Example:

```
HTTP/1.1 415 Unsupported Media Type
Content-Type: application/problem+json

{
	"type": "https://example.com/docs/api-errors#gone",
	"title": "Unsupported Media Type in 'Content-Type' header",
	"detail": "Invalid 'Content-Type' header provided. Must be one of the following: 'application/json'",
	"instance": "https://example.com/console/http-logs/{log_id}",
	"api_reference_link": "https://example.com/docs/api_reference#project-content-type"
}
```

### 429

Indicates a rate limit has been exceeded. See [Rate Limiting](#rate-limiting).

### 500

An API error occurred and a more specific error code applied.

```
HTTP/1.1 500 Internal Server Error
Content-Type: application/problem+json

{
	"type": "https://example.com/docs/api-errors#internal-server-error",
	"title": "Internal Server Error",
	"detail": "Internal Server Error: This should not ever happen.",
	"instance": "https://example.com/console/http-logs/{log_id}"
}
```

## Resource Names

APIs should adhere to the principles of REST because our APIs are RESTful.

- Separate things into logical Collections e.g. `projects` and `users`
- Collections are the collective term for Resources e.g. `projects`
- Resources are nouns not verbs
- Collections are plurals

Examples:

- `/projects` - `projects` is the collection name
- `/projects/{project_id}` - The project identified by `project_id` is the resource

## Resource Payload Structure

Resources and their relations should be represented using [JSON Hypertext Application Language](https://tools.ietf.org/html/draft-kelly-json-hal-08) because it is a simple and well understood implementation of hypermedia.

Example from the specification:

```
GET /orders/523 HTTP/1.1
Host: example.org
Accept: application/hal+json

HTTP/1.1 200 OK
Content-Type: application/hal+json

{
	"_links": {
		"self": { "href": "/orders/523" },
		"warehouse": { "href": "/warehouse/56" },
		"invoice": { "href": "/invoices/873" }
	},
	"currency": "USD",
	"status": "shipped",
	"total": 10.20
}
```

## Parameters and Properties

### Naming Format

Parameters and properties whether used within the URL as a query parameter or the body for a request or a response should be in [`snake_case`](https://en.wikipedia.org/wiki/Snake_case) so they are easy to read and to ensure they are consistently represented across all parts of the API.

Example in a query:

- `https://api.example.com/v1/projects?example_attribute=hello`

Example in a body response payload:

```json
{
	"page": {
		"size": 100,
		"number": 1,
		"total_pages": 1,
		"total_elements": 1
	},
	"_embedded": {
		"projects": [{
			"_links": {
				"self": {
					"href": "/project/{project_id}"
				}
			},
			"project_id": "{project_id}",
			"name": "My first project",
			"example_attribute": "hello"
		}]
	},
	"_links": {
		"self": "https://api.example.com/v1/projects?example_attribute=hello",
		"next": null,
		"prev": null
	}
}
```

### Identifier (ID) Property Names

Identifier property names should be fully qualified to remove any ambiguity regarding what resource the identifier is associated with. Do not use `id`. Instead use `{resource_name}_id` e.g. `project_id`.

### Date Identifiers

Dates should be in the format `{verb}ed_at` e.g. `created_at` and `updated_at`. This format makes it very clear what happened to the resource via the `verb` and the `_at` consistently identifies a date.

### Date Format

Dates should follow [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) because it is the most widely adopted representation of dates on the Internet. If the data is within a URL is should be URL encoded.

### Decimal Precision

All decimal values within the API will be returned to 4 decimal places with the exception of currency values where the number of decimal places will be defined by [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).

## Querying to Search or Filter

Searches should be performed by using RSQL (REST Structured Query Language) within the query of a URL which is a superset of [FIQL](https://tools.ietf.org/html/draft-nottingham-atompub-fiql-00). For more information see:

- [Grammar and semantics](https://github.com/jirutka/rsql-parser#grammar-and-semantic)
- [Examples](https://github.com/jirutka/rsql-parser#examples)

## Pagination

APIs should use one of the following pagination schemes:

* Page based for small, managed APIs where the customer is in control of what is in the data set e.g. the Projects collection
* Cursor based for ever-expanding data sets, or where it's infeasible to count the total number of records e.g. phone verification checks for a Project

To the customer, having two different pagination methods is OK, as in practice they should request the first page and then follow the `_links.next` URL to get the next page.

Page based pagination will be the default and cursor pagination can be decided by on a case-by-case basis. Results returned must be consistently ordered, and the customer can decide if the data set is returned in ascending or descending order.

### Page Based

In certain situations (e.g. reviewing Projects) it may be beneficial to skip over pages if you're not interested in that data.

The first page is page `1`.

- Paging should use a standard set of hal+json `_links`
	- `self` (current page, required)
	- `next` (next page, optional)
	- `prev` (previous page, optional)
	- `first` (first page, required)
	- `last` (last page, required)
- Paging `_links` must include filters.
- Paging body properties must be within a `page` object with the following properties:
	- The page size property must be called `size`
	- The current page property must be called `number`
	- The page count property must be called `total_pages`
	- The results property must be called `total_elements`
- Paging query parameters must be as follows:
	- The page size parameter must be called `size`
	- The current page parameter must be called `page`

```json
{
	"page": {
		"size": 100,
		"number": 3,
		"total_pages": 8,
		"total_elements": 814
	},
	"_embedded": {
		"resource_name": {
			"data":"here"
		}
	},
	"_links": {
		"self": {
			"href": "https://example.com/resource?size=100&order=asc&page=3"
		},
		"next": {
			"href": "https://example.com/resource?size=100&order=asc&page=4"
		},
		"prev": {
			"href": "https://example.com/resource?size=100&order=asc&page=2"
		},
		"last": {
			"href": "https://example.com/resource?size=100&order=asc&page=8"
		}
	}
}
```

### Cursor based

**STATUS: TBD**

> Cursors, if you’re not familiar, are like pointers. Pointers point at things, they reference a specific iota, a place in the list where your last request left off. A bookmark with breadcrumbs built in. (via [Slack](https://api.slack.com/docs/pagination#cursors))

- There should be a way to page through collections without additional filters.
- There should be a way to page through collections with filters.
- Cursors should not expire
- Paging should use a standard set of hal+json `_links`
	- `self` (current page, required)
	- `next` (next page, optional)
	- `prev` (previous page, optional)
	- `first` (first page, required)
- Paging `_links` must include filters.
- The page size parameter must be called `page_size`
- The cursor parameter must be called `cursor`

Example:

```json
{
	"page_size": 100,
	"cursor": "19284743",
	"_embedded": {
		"resource_name": {
			"data":"here"
		}
	},
	"_links": {
		"self": {
			"href": "https://example.com/resource?page_size=100&order=asc&cursor=19284743"
		},
		"next": {
			"href": "https://example.com/resource?page_size=100&order=asc&cursor=19291731"
		},
		"prev": {
			"href": "https://example.com/resource?page_size=100&order=asc&cursor=19283018"
		}
	}
}
```

## Errors

API errors should be represented using the structured outlined in [RFC7807](https://tools.ietf.org/html/rfc7807) (Problem Details for HTTP APIs) because it's a reasonably well understood and defined REST API error format. It also enables additional information to be provided in the problem payload that enables the API consumer to solve the problem.

Example:

```
HTTP/1.1 429 Forbidden
Content-Type: application/problem+json
Retry-After: 3600

{
	"type": "https://example.com/docs/api-errors#rate-limited",
	"title": "Rate Limited",
	"detail": "API rate limit exceeded. You can try again after 3000 seconds",
	"instance": "https://example.com/console/http-logs/{log_id}"
}
```

## Rate Limits

Rate limiting policies should be defined outside of API standards and may be defined on a per resource, group of resources, account or by some other defined group. The following explains how rate limiting should be exposed within APIs.

Where rate limits are required a resource should include the following within the HTTP response headers:

- X-RateLimit-Limit: The maximum number of requests available in the current time frame.
- X-RateLimit-Remaining: The number of remaining requests in the current time frame.
- X-RateLimit-Reset: A [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) of the expected time when the rate limit will reset.

Example:

```
HTTP/1.1 200 OK
Content-Type: application/hal+json
X-RateLimit-Limit: 5000
X-RateLimit-Remaining: 4966
X-RateLimit-Reset: 1372700873

{
	"_links": {
			"self": { "href": "/project/{project_id}" }
	},
	"project_id": "{project_id}",
	"name": "My first project",
}
```

If a rate limit is exceed a [429](#anchor-429) HTTP status code should be returned. Within the response there should be an a `Retry-After` HTTP header with a value indicating the number of seconds after which API interactions can be retried.

Example:

```
HTTP/1.1 429 Forbidden
Content-Type: application/problem+json
Retry-After: 3600

{
	"type": "https://example.com/docs/api-errors#rate-limited",
	"title": "Rate Limited",
	"detail": "API rate limit exceeded. You can try again after 3000 seconds",
	"instance": "https://example.com/console/http-logs/{log_id}"
}
```


## Acknowledgements & References

- Much of these standards follow an approached taken by the [Nexmo API Standards](https://github.com/Nexmo/api-standards)

# TODO

Tasks:

- [ ] Deprecation policy
- [ ] Move our API supported RSQL syntax and examples into this document. [Good example](https://developer.here.com/olp/documentation/data-client-library/dev_guide/client/rsql.html)
